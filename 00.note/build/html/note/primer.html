

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ch-ZH" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ch-ZH" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>14.8 函数调用运算符 &mdash; cplusplus 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="&lt;no title&gt;" href="../index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> cplusplus
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">14.8 函数调用运算符</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lambda">14.8.1 lambda是函数对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">14.8.2 标准库定义的函数对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function">14.8.3 可调用对象与function</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id3">14.9 重载、类型转换与运算符</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id4">14.9.1 类型转换运算符</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">定义含有类型转换运算符的类：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">类型转换运算符可能产生意外结果：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">显示的类型转换运算符：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bool">转换为bool：</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id8">第18章 用于大型程序的工具</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id9">18.3 多重继承与虚继承</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">18.3.1 多重继承</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">多重继承的派生类从每个基类中继承状态</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">派生类构造函数初始化所有基类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">继承的构造函数与多重继承</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">多重继承的派生类的拷贝与移动操作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">cplusplus</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>14.8 函数调用运算符</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/note/primer.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>14.8 函数调用运算符<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lambda">
<h2>14.8.1 lambda是函数对象<a class="headerlink" href="#lambda" title="Permalink to this headline">¶</a></h2>
<p><strong>当我们编写一个lambda后，编译器将该表达式翻译成一个未命名的命名对象</strong></p>
<p>例子：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//根据单词的长度对其进行排序</span>
<span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
            <span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
            <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();});</span>

<span class="c1">//其行为类似与下面这个类的一个未命名对象</span>
<span class="k">class</span> <span class="nc">ShortString</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>表示lambda及相应捕获行为的类：</strong></p>
<ul>
<li><p class="first">当一个lambda表达式通过引用捕获变量时，编译器可以直接使用该引用而无须再lambda产生的类中将其存储为数据成员。</p>
</li>
<li><p class="first">通过值捕获的变量被拷贝到lambda中时，lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。</p>
</li>
<li><p class="first">例子：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//获得第一个指向满足条件元素的迭代器，该元素满足size() is &gt;= sz</span>
<span class="k">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">worlds</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
                 <span class="p">[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
                  <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;});</span>

<span class="c1">//该lambda表达式产生的类将形如：</span>
<span class="k">class</span> <span class="nc">SizeComp</span><span class="p">{</span>
	<span class="n">SizeComp</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">sz</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span>	<span class="c1">//该形参对应捕获的变量  </span>
  	<span class="c1">//该调用运算符的返回类型、形参和函数体都与lambda一致</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span><span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">sz</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>	<span class="c1">//该数据成员对应通过只获取的变量</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2>14.8.2 标准库定义的函数对象<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类</p>
<p><strong>在算法中使用标准库函数对象：</strong></p>
<p>表示运算符的函数对象长用来替代算法中的默认运算符</p>
<p>需要特别注意的时，标准库规定其函数对象对于指针同样适用</p>
</div>
<div class="section" id="function">
<h2>14.8.3 可调用对象与function<a class="headerlink" href="#function" title="Permalink to this headline">¶</a></h2>
<p>c++语言中有几种可调用的对象：<font color=red>函数</font>、<font color=red>函数指针</font>、<font color=red>lambda表达式</font>、<font color=red>bind创建的对象</font></p>
<p><strong>可调用的对象也有类型：</strong></p>
<ul class="simple">
<li>每个lambda有它自己唯一的（未命名）类类型；</li>
<li>函数及函数指针的类类型则由其返回值类型和实参类型决定，等等</li>
</ul>
<p>**调用形式：**指明了调用返回的类型以及传递给调用的实参类型。一种函数形式对应一个函数类型（注意函数类型和可调用对象类型不是一个概念），例如：</p>
<p>​	int (int, int)</p>
<p>是一个函数类型，它接受两个int、返回一个int</p>
<p><strong>不同类型可能具有相同的调用形式：</strong></p>
<p>对于几个可调用对象共享同一种对用形式的情况，有时<font color=red>希望把它们看成具有相同的类型</font>。</p>
<p>如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//普通函数</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">//lambda,其产生一个未命名的函数对象类</span>
<span class="k">auto</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">;};</span>
<span class="c1">//函数对象类</span>
<span class="k">struct</span> <span class="n">divide</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">(</span><span class="kt">int</span> <span class="n">denominator</span><span class="p">,</span> <span class="kt">int</span> <span class="n">divisor</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">denominator</span> <span class="o">/</span> <span class="n">devicsor</span><span class="p">;</span>
    <span class="p">}</span>   
<span class="p">}</span>
</pre></div>
</div>
<p><font color=red>尽管上面的可调用对象类型各不相同，但是共享同一种调用形式：</font></p>
<p>int (int, int);</p>
<p>为了实现这一目的，需要定义一个<strong>函数表</strong>用于存储指向这些可调用对象的“指针”，当程序需要指向某个特定操作时，从表中查找该调用函数，如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//构建从运算符到函数指针的映射关系，其中函数接受两个int、返回一个int</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">binops</span><span class="p">;</span>
</pre></div>
</div>
<p>我们可以按照下面的形式将add的指针添加到binops中：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//正确:add是一个指向正确类型函数的指针</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span> <span class="c1">//{&quot;+&quot;, add}是一个pair</span>
</pre></div>
</div>
<p>但是不能将mod或者divide存入binops中(问题在于mod是个lambda表达式，而每个lambda有它自己的类类型，该类型与存储在binops中的值的类型不匹配):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&quot;%&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="p">});</span> <span class="c1">//错误：mod不是一个函数指针</span>
</pre></div>
</div>
<p><strong>标准库function类型：</strong></p>
<p>为了解决上述问题，我们可以使用一个名未<strong>function</strong>的新的标准库类型解决上述问题。(function定义在functional头文件中，标14.3列举了function定义的操作，详情可见p512)</p>
<p><font color=red>function是一个模板</font></p>
<p>我们可以使用如下方式，表示任何一种可调用对象类型：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span>
<span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>		<span class="c1">//函数指针</span>
<span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">divide</span><span class="p">();</span>	<span class="c1">//函数对象类的对象</span>
<span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="c1">//lambda</span>
							<span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f3</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>因此我们可以使用下面的形式重新定义map，解决上述问题：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span><span class="p">;</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">functin</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">},</span>									<span class="c1">//函数指针</span>
    <span class="p">{</span><span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}},</span>					<span class="c1">//标准库函数对象</span>
    <span class="p">{</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="p">()},</span>							<span class="c1">//用户定义的函数对象</span>
    <span class="p">{</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;}},</span>	<span class="c1">//未命名的lambda</span>
    <span class="p">{</span><span class="s">&quot;%&quot;</span><span class="p">,</span> <span class="n">mod</span><span class="p">}</span>									<span class="c1">//名了名的lambda对象</span>
<span class="p">}</span>

<span class="c1">//调用</span>
<span class="n">binops</span><span class="p">[</span><span class="s">&quot;+&quot;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>	<span class="c1">//调用add(10,5)</span>
<span class="n">binops</span><span class="p">[</span><span class="s">&quot;-&quot;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>	<span class="c1">//调用minus&lt;int&gt;对象的调用运算符</span>
<span class="p">...</span>
</pre></div>
</div>
<p><strong>重载的函数与function:</strong></p>
<p>我们<font color=red>不能(直接)将重载函数的名字存入function类型的对象中</font>，会产生二义性,比如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;}</span>
<span class="n">Sales_data</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span><span class="p">;</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="p">{</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">}</span> <span class="p">);</span>	<span class="c1">//错误：哪个add?</span>
</pre></div>
</div>
<p>解决上述二义性问题，有两条途径：</p>
<ul>
<li><p class="first">存储函数指针而非函数的名字：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>		<span class="c1">//指针所指的add是接受两个int的版本</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">fp</span><span class="p">});</span>		<span class="c1">//正确：fp指向一个正确的add版本</span>
</pre></div>
</div>
<p>​</p>
</li>
<li><p class="first">使用lambda来消除二义性：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//正确：使用lambda来指定我们希望使用的add版本</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}});</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="id3">
<h1>14.9 重载、类型转换与运算符<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h1>
<p><strong>类类型转换（class-type conversions）：</strong><font color=red>转换构造函数</font>和<font color=red>类型转换运算符</font>共同定义了类类型转换（class-type conversions），这样的转换有时也被称作<strong>用户定义的类型转换(user-defined conversions)</strong></p>
<div class="section" id="id4">
<h2>14.9.1 类型转换运算符<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>**类类型转换运算符(conversion operator)：**是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。</p>
<p>类型转换函数的一般形式如下所示：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">operator</span> <span class="nf">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">//其中type表示某种类型</span>
</pre></div>
</div>
<p><font color=red>注：</font></p>
<ul class="simple">
<li>类型转换运算符可以面向任意类型（处理void之外）进行定义，只要该类型能作为函数的返回类型。因此，我们不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。</li>
<li>一个类型转换函数必须是类的成员函数：它不能是声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。</li>
</ul>
<div class="section" id="id5">
<h3>定义含有类型转换运算符的类：<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>例子：</p>
<p>​	定义一个类，令其表示0到255之间的一个整数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SmallInt</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&quot;Bad SmallInt value&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>SmallInt类既定义了向类类型的转换（构造函数），也定义了从类类型向其他类型的转换（类型转换运算符）</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">si</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>	<span class="c1">//首先将4隐隐式地转化成SmallInt,然后调用SmallInt::operator=</span>
<span class="n">si</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">//首先将si隐式地转成int，然后指向整数的加法</span>
</pre></div>
</div>
<p>因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能再类型转换运算符的定义中使用任何形参。同时，景观类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SmallInt</span><span class="p">;</span>
<span class="k">operator</span> <span class="nf">int</span><span class="p">(</span><span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">);</span>		<span class="c1">//错误：不是成员函数</span>
<span class="k">class</span> <span class="nc">SmallInt</span><span class="p">{</span>
    <span class="kt">int</span> <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>		<span class="c1">//错误：指定了返回类型</span>
    <span class="k">operator</span> <span class="nf">int</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>	<span class="c1">//错误：参数列表不为空</span>
    <span class="k">operator</span> <span class="kt">int</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;}</span>	<span class="c1">//错误：42不是一个指针</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>类型转换运算符可能产生意外结果：<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>	<span class="c1">//如果向bool的类型转换不是显示的，则该代码再编译器看来将是合法的</span>
</pre></div>
</div>
<p><font color=red>说明：</font>这段代码试图将输出运算符作用于输入流。因为istream本身并没有定义&lt;&lt;，所以本来代码应该产生错误。然而，该代码能使用istream的bool类型转换运算符将cin转换成bool，而这个bool值接着会被提升成int并作内置的左移运算符的左侧运算对象。这样用来，提升后的bool值（0或1）最终会被左移42个位置。这一结果与我们预期大相径庭。</p>
</div>
<div class="section" id="id7">
<h3>显示的类型转换运算符：<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>为了防止上述的异常情况，c++11引入了显式的类型转换运算符（explicit conversion operator）:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SmallInt</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//编译器不会自动执行这一类型转换</span>
    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;}</span>
	<span class="c1">//其他成员与之前的版本一致    </span>
<span class="p">};</span>
</pre></div>
</div>
<ul>
<li><p class="first">当类型转换运算符是显式的时候，必修通过显式的强制类型转换才可以：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SmallInt</span> <span class="n">si</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">//正确：Smaill的构造函数不是显式的</span>
<span class="n">si</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>				<span class="c1">//错误：此处需要隐式的类型转换，但类的运算符是显式的</span>
<span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">//正确：显式地请求类型转换</span>
</pre></div>
</div>
</li>
<li><p class="first"><font color=red>这一规定存在一个例外，即如果表达式被用作条件，则编译器 会将显式的类型转换自动应用与它。</font>当表达式出现在下列位置时，显式的类型转换将被隐式地执行：</p>
<ul class="simple">
<li>if、while及do语句的条件部分</li>
<li>for语句的条件表达式</li>
<li>逻辑非运算符(!)、逻辑或运算符(||)、逻辑与运算符(&amp;&amp;)的运算对象</li>
<li>条件运算符（?:）的条件表达式</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="bool">
<h3>转换为bool：<a class="headerlink" href="#bool" title="Permalink to this headline">¶</a></h3>
<p><strong>在c++11新标准下，IO标准库通过定义一个向bool的显式类型转换，避免上述提到的问题：</strong></p>
<p><font color=red>无论我们说明时候在条件中是用哪个流对象，都会使用为IO类型定义的operator bool。</font></p>
<p>例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>解释：while语句的条件执行了输入运算符，它负责将数据读入到value并返回cin。为了对条件求值，cin被istream operator bool类型转换函数隐式地执行了转换（cin被专程了bool类型）。</p>
</div>
</div>
</div>
<div class="section" id="id8">
<h1>第18章 用于大型程序的工具<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id9">
<h2>18.3 多重继承与虚继承<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>**多重继承（multiple inheritance）：**是指从多个直接基类中产生派生类的能力。</p>
<div class="section" id="id10">
<h3>18.3.1 多重继承<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>在派生类的派生列表中可用包含多个基类：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bear</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ZooAnimal</span><span class="p">{}</span>
<span class="k">class</span> <span class="nc">Panda</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bear</span><span class="p">,</span> <span class="k">public</span> <span class="n">Endangered</span> <span class="p">{};</span>
</pre></div>
</div>
<ul class="simple">
<li>每个基类包含一个可选的访问说明符，如果访问说明符被忽略掉了，则关键字class对应的默认访问说明符是private，关键字struct对应的是public</li>
<li>对于派生类能够继承的基类个数，c++没有进行特殊规定</li>
</ul>
<div class="section" id="id11">
<h4>多重继承的派生类从每个基类中继承状态<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p><img alt="note\assets/%E5%9B%BE18-2-1552307078545.jpg" src="note\assets/%E5%9B%BE18-2-1552307078545.jpg" />图18-2</p>
<p>在Panda对象中含有一个Bear部分（其中又含有一个ZooAnimal部分）、一个Endangered部分以及在Panda中声明的非静态数据成员</p>
</div>
<div class="section" id="id12">
<h4>派生类构造函数初始化所有基类<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>基类的构造顺序与派生类列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。</p>
</div>
<div class="section" id="id13">
<h4>继承的构造函数与多重继承<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>在c++11新标准中，允许派生类从它的一个或几个基类中继承构造函数，但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>struct Base1{
    Base1() = default;
    Base1(const std::string&amp;);
    Base1(std::shared_ptr&lt;int&gt;);
};

struct Base2{
    Base2() = default;
    Base2(const std::string&amp;);
    Base2(int);
};

//错误：D1试图从两个基类中都继承D1:D1(const string&amp;)
struct D1: public Base1， public Base2{
    using Base1::Base1;	//从Base1继承构造函数
    using Base2::Base2;	//从Base2继承构造函数
};
</pre></div>
</div>
<p>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必修为该构造函数定义它自己的版本：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nl">D2</span><span class="p">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span><span class="p">{</span>
    <span class="k">using</span> <span class="n">Base1</span><span class="o">::</span><span class="n">Base1</span><span class="p">;</span>	<span class="c1">//从Base1继承构造函数</span>
    <span class="k">using</span> <span class="n">Base2</span><span class="o">::</span><span class="n">Base2</span><span class="p">;</span>	<span class="c1">//从Base2继承构造函数</span>
    <span class="c1">//D2必须自定义一个接受string的构造函数</span>
    <span class="n">D2</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">Base1</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">Base2</span><span class="p">(</span><span class="n">s</span><span class="p">){}</span>
    <span class="n">D2</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>	<span class="c1">//一旦D2定义了它自己的构造函数，则必须出现</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>多重继承的派生类的拷贝与移动操作<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作</li>
<li>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作</li>
</ul>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../index.html" class="btn btn-neutral float-left" title="&lt;no title&gt;" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ahwi

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>